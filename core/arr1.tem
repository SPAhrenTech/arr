// arrays (n) - P. Ahrenkiel

#include <math.h>

#include "error.hpp"
#include "arr2slice.hpp"

namespace arr {

template <class data_type>
arr1<data_type>::arr1(const size_t n, const data_type* p):
	_v(n)
{
	if(p)
   	_v.assign(p,p+n);
}

template <class data_type>
arr1<data_type>::arr1(const std::vector<data_type>& A):_v(A)
{
}


template <class data_type>
arr1<data_type>::arr1(const arr1<data_type>& A)
{
    _v=A._v;
}

template <class data_type>
arr1<data_type>::arr1(std::initializer_list<data_type> A):arr1(std::vector(A)){}
	
template <class data_type>
arr1<data_type>& arr1<data_type>::operator=(const arr1<data_type>& A)
{
    _v=A._v;
}

template <class data_type>
arr1<data_type> arr1<data_type>::reverse()
{
	return std::vector<double>(_v.rbegin(),_v.rend());
}

template <class data_type>
void arr1<data_type>::resize(const std::size_t n)
{
    _v.resize(n);
}

template <class data_type>
void arr1<data_type>::append(const data_type x)
{
    _v.push_back(x);
}


template <class data_type>
arr1<data_type>::~arr1()
{
}

//
template <class data_type>
bool arr1<data_type>::operator==(const arr1<data_type>& A) const
{
    bool res = true;
    if (A.size() != size()) {
        return false;
    }
    for(std::size_t i = 0; i < size(); ++i)
        res = res & (_v[i] == A(i));
    return res;
}

template <class data_type>
arr1<data_type> arr1<data_type>::operator=(const data_type& x)
{
    for(std::size_t i = 0; i < size(); ++i)
   		at(i) = x;
    return *this;
}

template <class data_type>
bool arr1<data_type>::operator!=(const arr1& A) const
{
    return !((*this) == A);
}

template <class data_type>
data_type& arr1<data_type>::at(const std::size_t i)
{
    return _v[i];
}

template <class data_type>
data_type const& arr1<data_type>::at(const std::size_t i) const
{
	return _v[i];
}

template <class data_type>
data_type& arr1<data_type>::operator()(const std::size_t i)
{
	return at(i);
}

template <class data_type>
data_type const& arr1<data_type>::operator()(const std::size_t i) const
{
	return at(i);
}

template <class data_type>
data_type* arr1<data_type>::data()
{
	return _v.data();
}

template <class data_type>
data_type const* arr1<data_type>::data() const
{
	return _v.data();
}


template <class data_type>
void arr1<data_type>::copy(data_type* a) const
{
	for(auto &x:*this)
	{
		*a=x;
		++a;
	}
}

template <class data_type>
arr1<std::size_t> arr1<data_type>::iindex() const
{
    arr1<data_type> res(size());
    for (std::size_t i = 0; i < _v.size(); ++i)
        res(i) = i;
    return res;
}

template <class data_type>
arr1<data_type> arr1<data_type>::operator()(const arr1<std::size_t> A)
{
    std::size_t m = A.size();
    arr1<data_type> res(m);
    for (std::size_t i = 0; i < m; ++i)
        res(i) = _v[A(i)];
}

template <class data_type>
std::vector<data_type> arr1<data_type>::operator()() const
{
    return _v;
}

template <class data_type>
std::ostream& operator<<(std::ostream& os, const arr1<data_type>& A)
{
    os << "(";
    for (size_t i = 0; i < A.size(); ++i) {
        if (i > 0)
            os << "\t";
        os << A(i);
    }
    os << ")";
    return os;
}

template <class data_type>
void arr1<data_type>::clear()
{
	_v.clear();
}

template <class data_type>
std::size_t arr1<data_type>::size() const
{
	return _v.size();
}

template <class data_type>
data_type& arr1<data_type>::cyc(const std::size_t i)
{
	return (*this)(i % size());
}

template <class data_type>
data_type const& arr1<data_type>::cyc(const std::size_t i) const
{
	return (*this)(i & size());
}

template <class data_type>
arr1<data_type>::arr1(const arr2slice<data_type>& A):arr1<data_type>(A.size())
{
	for (std::size_t i = 0; i < size(); i++)
	at(i) = A(i);
}

template <class data_type>
arr1<data_type>& arr1<data_type>::operator=(const arr2slice<data_type>& A)
{
	return *this = arr1<data_type>(A);
}

} // namespace arr
