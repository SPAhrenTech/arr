// arrays (m x n) - P. Ahrenkiel

#include <cstdlib>
#include <math.h>
#include <iostream>

#include "error.hpp"

namespace arr {

template <class data_type>
arr2<data_type>::arr2(const std::size_t nRows, std::size_t nCols, const data_type* p)
    :_nRows(nRows), _nCols(nCols), _v(nRows*nCols)
{
	if(p)
		_v.assign(p,p+nRows*nCols);
}

template <class data_type>
arr2<data_type>::arr2(const std::size_t nRows,const std::size_t nCols,const std::vector<data_type> &v)
:_nRows(nRows), _nCols(nCols),_v(v)
{
}

template <class data_type>
arr2<data_type>::arr2(const arr1<data_type>& A) : arr2(A.size(), 1)
{
    for (std::size_t i = 0; i < _nRows; ++i)
			_v[i] = A(i);
}

// copy constructor
template <class data_type>
arr2<data_type>::arr2(const arr2<data_type>& A):arr2(A.size(0),A.size(1),A._v)
{
}

template <class data_type>
arr2<data_type>::arr2(std::initializer_list<std::initializer_list<data_type>> A)
{
	_nRows = _nCols = 0;
	bool first = true;
	for(auto &aRow:A)
	{
		if (first)
	 		_nCols = aRow.size();
		if(aRow.size() < _nCols)
			_nCols = aRow.size();
		first = false;
		++_nRows;
	}
	_v.resize(size());
	std::size_t i = 0;
	for(auto &aRow:A)
	{
		std::size_t j = 0;
		for(auto &a:aRow)
		{
			if (j < _nCols)
				_v[i * _nCols + j] = a;
			++j;
		}
		++i;
	}
}

template <class data_type>
arr2<data_type>::~arr2()
{
    _nRows = _nCols = 0;
}

//
template <class data_type>
arr2<data_type>& arr2<data_type>::operator=(const arr2<data_type>& A)
{
    _nRows = A._nRows;
    _nCols = A._nCols;
    _v.resize(size());
		for (std::size_t i = 0; i < _nRows; i++)
				for (std::size_t j = 0; j < _nCols; j++)
						at(i,j) = A(i,j);

    return *this;
}

template <class data_type>
arr2<data_type>& arr2<data_type>::operator=(const data_type& x)
{
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            at(i,j) = x;

    return *this;
}

//
template <class data_type>
std::size_t arr2<data_type>::size(const std::size_t d) const
{
    switch (d) {
    case 0:
        return _nRows;
    case 1:
        return _nCols;
    default:
        return 0;
    }
}

//
template <class data_type>
void arr2<data_type>::resize(const size_t nRows, const size_t nCols)
{
	_v.resize(nRows,nCols);
}

//
template <class data_type>
bool arr2<data_type>::operator==(const arr2<data_type>& A) const
{
    bool res = (_nRows == A._nRows) && (_nCols == A._nCols);
    if (res) {
        for (std::size_t i = 0; i < _nRows; i++)
            for (std::size_t j = 0; j < _nCols; j++)
                res = res & (at(i,j) == A(i,j));
    }
    return res;
}

//
template <class data_type>
bool arr2<data_type>::operator!=(const arr2<data_type>& A) const
{
    return !((*this) == A);
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::T() const
{
    arr2<data_type> res(_nCols, _nRows);
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            res(j, i) = at(i, j);
    return res;
}

//
template <class data_type>
arr1<data_type> arr2<data_type>::operator()(const std::size_t j) const
{
    std::size_t nRows = _nRows;
    arr1<data_type> res(nRows);
    if (j > _nCols) {
        err = -1;
        return res;
    }
    for (std::size_t i = 0; i < nRows; i++)
        res(i) = at(i, j);
    return res;
}


template <class data_type>
arr2<data_type>::arr2(const arr2sub<data_type>& A) : arr2<data_type>(A.size(0), A.size(1))
{
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            at(i, j) = A(i, j);
}

//
template <class data_type>
arr2sub<data_type> arr2<data_type>::sub(const std::size_t iRow,
                                        const std::size_t iCol,
                                        const std::size_t nRows,
                                        const std::size_t nCols)
{
    return arr2sub<data_type>(this, iRow, iCol, nRows, nCols);
}

//
template <class data_type>
arr2sub<data_type> arr2<data_type>::operator()(const std::size_t iRow,
                                               const std::size_t iCol,
                                               const std::size_t nRows,
                                               const std::size_t nCols)
{
    return sub(iRow, iCol, nRows, nCols);
}

//
template <class data_type>
arr2slice<data_type> arr2<data_type>::slice(const std::size_t iDim, const std::size_t iIndex)
{
    std::size_t nSize = size(iDim);
    if (iDim == 0) {
        arr2slice<data_type> res(this, iIndex, nSize);
        return res;
    }
    arr2slice<data_type> res(this, nSize, iIndex);
    return res;
}

//
template <class data_type>
arr2slice<data_type> arr2<data_type>::row(const std::size_t iRow)
{
    return slice(0, iRow);
}

//
template <class data_type>
arr2slice<data_type> arr2<data_type>::col(const std::size_t iCol)
{
    return slice(1, iCol);
}

//
template <class data_type>
arr2<std::size_t> arr2<data_type>::icol() const
{
    arr2<std::size_t> res(_nRows, _nCols);
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            res(i, j) = j;
    return res;
}

//
template <class data_type>
arr2<std::size_t> arr2<data_type>::irow() const
{
    arr2<std::size_t> res(_nRows, _nCols);
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            res(i, j) = i;
    return res;
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::operator()(const arr2<std::size_t> A, const arr2<std::size_t> B)
{
    if (_nRows > B._nRows)
        _nRows = B._nRows;
    if (_nCols > B._nCols)
        _nCols = B._nCols;
    arr2<data_type> res(_nRows, _nCols);
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            res(i, j) = at(A(i, j), B(i, j));
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::operator()(const arr2<std::size_t> A, const std::size_t Bi)
{
    arr2<data_type> res(_nRows, _nCols);
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            res(i, j) = at(A(i, j), Bi);
}

//
template <class data_type>
arr2<data_type> arr2<data_type>::operator()(const std::size_t Ai, const arr2<std::size_t> B)
{
    arr2<data_type> res(_nRows, _nCols);
    for (std::size_t i = 0; i < _nRows; i++)
        for (std::size_t j = 0; j < _nCols; j++)
            res(i, j) = at(Ai, B(i, j));
}

template <class data_type>
bool arr2<data_type>::swapRows(const std::size_t iRow1, const std::size_t iRow2)
{
    if (!((iRow1 < _nRows) && (iRow2 < _nRows)))
        return false;
    for (std::size_t k = 0; k < _nCols; k++) {
        data_type x = at(iRow1, k);
        at(iRow1, k) = at(iRow2, k);
        at(iRow2, k) = x;
    }
    return true;
}

template <class data_type>
bool arr2<data_type>::swapCols(const std::size_t iCol1, const std::size_t iCol2)
{
    if (!((iCol1 < _nCols) && (iCol2 < _nCols)))
        return false;
    for (std::size_t k = 0; k < _nRows; k++) {
        data_type x = at(k, iCol1);
        at(k, iCol1) = at(k, iCol2);
        at(k, iCol2) = x;
    }
    return true;
}

template <class data_type>
std::ostream& operator<<(std::ostream& os, const arr2<data_type>& A)
{
    for (size_t i = 0; i < A.size(0); i++) {
        for (size_t j = 0; j < A.size(1); j++) {
            if (j > 0)
                os << "\t";
            os << A(i, j);
        }
        os << std::endl;
    }
    return os;
}

template <class data_type>
arr2<data_type> arr2<data_type>::minor(const std::size_t m, const std::size_t n) const
{
    arr2<data_type> res(_nRows - 1, _nCols - 1);
    size_t ip = 0;
    for (size_t i = 0; i < _nRows; i++)
        if (i != m) {
            size_t jp = 0;
            for (size_t j = 0; j < _nCols; j++)
                if (j != n) {
                    res(ip, jp) = at(i, j);
                    jp++;
                }
            ip++;
        }
    return res;
}

template <class data_type>
std::vector<data_type> arr2<data_type>::operator()() const
{
    return _v;
}

template <class data_type>
data_type& arr2<data_type>::at(const std::size_t i, const std::size_t j)
{
    return _v.at(i * _nCols + j);
}

template <class data_type>
data_type const& arr2<data_type>::at(const std::size_t i, const std::size_t j) const
{
    return _v.at(i * _nCols + j);
}

template <class data_type>
data_type& arr2<data_type>::operator()(const std::size_t i, const std::size_t j)
{
	return at(i, j);
}

template <class data_type>
data_type const& arr2<data_type>::operator()(const std::size_t i, const std::size_t j) const
{
	return at(i, j);
}

template <class data_type>
data_type* arr2<data_type>::data()
{
	return _v.data();
}

template <class data_type>
data_type const* arr2<data_type>::data() const
{
	return _v.data();
}

} // namespace arr
