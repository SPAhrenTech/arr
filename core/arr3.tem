// arrays (l x m x n) - P. Ahrenkiel

#include "arr1.hpp"
#include "arr2.hpp"
#include "arr2sub.hpp"
#include "arr2slice.hpp"

namespace arr {

template <class data_type>
arr3<data_type>::arr3(const std::size_t n0,
                      const std::size_t n1,
                      const std::size_t n2,
                      const data_type* p)
    : _n0(n0),_n1(n1),_n2(n2),_v(n0*n1*n2)
{
	if(p)
		_v.assign(p,p+n0*n1*n2);
}

// copy constructor
template <class data_type>
arr3<data_type>::arr3(const arr3<data_type>& A):arr3(A.size(0),A.size(1),A.size(2),A.data())
{
}

template <class data_type>
arr3<data_type>::~arr3()
{
	_n0=_n1=_n2=0;
}

template <class data_type>
std::vector<data_type> arr3<data_type>::operator()() const
{
    return _v;
}

template <class data_type>
arr3<data_type>& arr3<data_type>::operator=(const arr3<data_type>& A)
{
    _n0 = A._n0;
    _n1 = A._n1;
    _n2 = A._n2;
    _v = A._v;

    return *this;
}

template <class data_type>
arr3<data_type>& arr3<data_type>::operator=(const data_type& x)
{
	std::fill(_v.begin(),_v.end(),x);
	return *this;
}

template <class data_type>
std::size_t arr3<data_type>::size() const { return _n0 * _n1 * _n2; }
	
template <class data_type>
std::size_t arr3<data_type>::size(const std::size_t d) const
{
    switch (d) {
    case 0:
        return _n0;
    case 1:
        return _n1;
    case 2:
        return _n2;
    default:
        return 0;
    }
}

template <class data_type>
bool arr3<data_type>::isCube() const
{
	return (_n0 == _n1) && (_n0 == _n2);
}
	
template <class data_type>
void arr3<data_type>::resize(const size_t n0, const size_t n1, const size_t n2)
{
	_n0=n0;_n1=n1;_n2=n2;
	_v.resize(n0 * n1 * n2);
}

template <class data_type>
bool arr3<data_type>::operator==(const arr3<data_type>& A) const
{
    bool res = (_n0 == A._n0) && (_n1 == A._n1) && (_n2 == A._n2);
    if (res)
    {
        for (std::size_t i = 0; i < _n0; ++i)
            for (std::size_t j = 0; j < _n1; ++j)
                for (std::size_t k = 0; k < _n2; ++k)
                    res = res & (at(i, j, k) == A(i, j, k));
    }
    return res;
}

template <class data_type>
bool arr3<data_type>::operator!=(const arr3<data_type>& A) const
{
    return !((*this) == A);
}

template <class data_type>
data_type& arr3<data_type>::at(const std::size_t i, const std::size_t j, const std::size_t k)
{
    return _v.at(i * _n1 * _n2 + j * _n2 + k);
}

template <class data_type>
data_type const& arr3<data_type>::at(const std::size_t i, const std::size_t j, const std::size_t k) const
{
    return _v.at(i * _n1 * _n2 + j * _n2 + k);
}

template <class data_type>
data_type& arr3<data_type>::operator()(const std::size_t i, const std::size_t j, const std::size_t k)
{
	return at(i, j, k);
}

template <class data_type>
data_type const& arr3<data_type>::operator()(const std::size_t i, const std::size_t j, const std::size_t k) const
{
	return at(i, j, k);
}

template <class data_type>
data_type* arr3<data_type>::data()
{
	return _v.data();
}

template <class data_type>
data_type const* arr3<data_type>::data() const
{
	return _v.data();
}

} // namespace arr
